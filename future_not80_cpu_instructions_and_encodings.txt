Note that register pairs are fixed to have their high byte stored in a
register rX and their low byte stored in another register r(X + 1) such
that X is an even number.  

Here are some example register pairs:  r0p (high byte r0, low byte r1), 
  r2p (high byte r2, low byte r3), r4p (high byte r4, low byte r5), etc.


Special register pairs:  
  1)  The program counter's two bytes are stored in the register pair
  r14p.  If there is ever an assembler for this CPU, "pc" (without
  quotes) will be an alias for "r14p" (without quotes).
  2)  The link register's two bytes are stored in the register pair r12p
  (enforced by the hardware, but only relevant to the call and calli
  instructions).  If there is ever an assembler for this CPU, "lr" (without
  quotes) will be an alias for "r12p" (without quotes).
  3)  As an ASSEMBLER CONVENTION, the stack pointer's two bytes are stored
  in the register pair r10p.  If there is ever an assembler for this
  CPU, "sp" (without quotes) will be an alias for "r10p" (without
  quotes).



Instruction encodings:

Group 1 (Non-branching instructions with 8-bit immediate values):  
  Encoding:  0ooo aaaa iiii iiii
  Encoding description:  op (o); 
    register rA, or reg pair r(aaaa/2)p [denoted rAp, so the least
    significant bit of aaaa is ignored] (a); 
    8-bit immediate value (i)
  Instructions:  
    Arithmetic instructions:
      1. addi
      2. adci
      3. addpbi (ADd 8-bit Immediate value to reg Pair rAp)
      
      4. subi (ASSEMBLER ALIAS for addi with the two's complement of the
      immediate value)
      
      5. sbci (ASSEMBLER ALIAS for adci with the one's complement of the
      immediate value)
      
      6. subpbi (SuBtract 8-bit Immediate value from reg Pair rAp [NOT an
      assembler alias for addpbi])
      
      7. cmpi
    
    Copy instructions:
      8. cpyi (CoPY Immediate)


Group 2 (The instruction group with the most opcodes):  
  Encoding:  10oo oooo aaaa bbbb
  Encoding description:  op (o); 
    register rA, or reg pair r(aaaa/2)p [denoted rAp, so the least
    significant bit of aaaa is ignored] (a); 
    register rB, or reg pair r(bbbb/2)p [denoted rBp, so the least
    significant bit of bbbb is ignored] (b)
  Instructions:  
    Arithmetic instructions:
      1. add
      2. adc
      3. addpb (ADd register rB to reg Pair rAp)
      
      4. sub
      5. sbc
      6. subpb (SuBtract 8-bit register rB from reg Pair rAp)
      
      7. cmp
      
      8. umul (Unsigned MULtiply rA by rB, storing results in r0p [16-bit,
      big endian])
      9. smul (Signed MULtiply rA by rB, storing results in r0p [16-bit,
      big endian])
    
    Bitwise instructions with two register operands:
      1. and
      2. orr
      3. xor
    
    Complement instructions with one register operand (rB ignored):
      1. inv (one's complement of rA)
      2. invp (one's complement of rAp)
      3. neg (two's complement of rA)
      4. negp (two's complement of rAp) 
    
    Bitshifting (and rotating) instructions that use the value of rB as the
    number of bits to shift by:
      1. lsl
      2. lsr
      3. asr
      4. rol
      5. ror
    
    Bit rotating instructions that use carry as bit 8 for a 9-bit rotate
    of { carry, rA } by one bit:
      1. rolc
      2. rorc
    
    Bitshifting (and rotating) instructions that do a 16-bit shift or
    rotate on the reg pair rAp, using rB as the number of bits to shift by:
      1. lslp
      2. lsrp
      3. asrp
      4. rolp
      5. rorp
    
    Bit rotating instructions that use carry as bit 16 for a 17-bit rotate
    of { carry, rAp } by one bit:
      1. rolcp
      2. rorcp
    
    Copy instructions:
      1. cpy (CoPY from reg rB to reg rA)
      2. cpyp (CoPY from reg Pair rBp to reg Pair rAp)
      
    Swap instructions:
      1. swp (SWap register Pair, also can be used as a combined "call",
      "jump", and "return" instruction by swapping some other register pair
      with the "pc" [r14p] register pair)
    
    Call instruction (Description:  sets the link register to the return
    address, then sets the program counter to the address contained in
    the reg pair rAp):
      1. call (CALL subroutine at address in reg pair rAp)
    
    8-bit Load/store instructions:
      1. ldr (LoaD contents into Register rA from memory)
      2. str (STore Register rA contents to memory)
      
      
    8-bit Push/pop style instructions:
      1. ldraa (LoaD contents into Register rA from memory at address
      contained in reg pair rBp, then Add 1 to the reg pair rBp)
      
      2. straa (STore Register rA contents to memory at address contained
      in reg pair rBp, then Add 1 to the reg pair rBp)
      
      
      3. ldrab (add 1 to the reg pair rBp, then LoaD contents into Register
      rA from memory at address contained in reg pair rBp)
      
      4. strab (add 1 to the reg pair rBp, then STore Register rA contents
      to memory at address contained in reg pair rBp)
      
      
      5. ldrsa (LoaD contents into Register rA from memory at address
      contained in reg pair rBp, then Subtract 1 from the reg pair rBp)
      
      6. strsa ([STore Register, Subtract After] STore Register rA contents
      to memory at address contained in reg pair rBp, then Subtract 1 from
      the reg pair rBp)
      
      
      7. ldrsb (Subtract 1 from the reg pair rBp, then LoaD contents into
      Register rA from memory at address contained in reg pair rBp)
      
      8. strsb (Subtract 1 from the reg pair rBp, then STore Register rA
      contents to memory at address contained in reg pair rBp)
    
    16-bit Load/store instructions:
      1. ldp (LoaD 16-bit contents [big endian] into reg Pair rAp from
      memory at address contained in reg pair rBp)
      
      2. stp (Store 16-bit contents [big endian] of reg Pair rAp to memory
      at address contained in reg pair rBp)
      
      
    16-bit Push/pop style instructions:
      1. ldpaa (LoaD 16-bit contents [big endian] into reg Pair rAp from
      memory at address contained in reg pair rBp, then Add 2 to the reg
      pair rBp)
      
      2. stpaa (STore 16-bit contents [big endian] of reg Pair rAp to
      memory at address contained in reg pair rBp, then Add 2 to the reg
      pair rBp)
      
      
      3. ldpab (Add 2 to the reg pair rBp, then LoaD 16-bit contents [big
      endian] into reg Pair rAp from memory at address contained in reg
      pair rBp)
      
      4. stpab (Add 2 to the reg pair rBp, then STore 16-bit contents [big
      endian] of reg Pair rAp to memory at address contained in reg pair
      rBp)
      
      
      5. ldpsa (LoaD 16-bit contents [big endian] into reg Pair rAp from
      memory at address contained in reg pair rBp, then Subtract 2 from the
      reg pair rBp)
      
      6. stpsa (STore 16-bit contents [big endian] of reg Pair rAp to
      memory at address contained in reg pair rBp, then Subtract 2 from the
      reg pair rBp)
      
      
      7. ldpsb (Subtract 2 from the reg pair rBp, then LoaD 16-bit contents
      [big endian] into reg Pair rAp from memory at address contained in
      reg pair rBp)
      
      8. stpsb (Subtract 2 from the reg pair rBp, then STore 16-bit
      contents [big endian] of reg Pair rAp to memory at address contained
      in reg pair rBp)


Group 3 (Instructions with one register and two register pairs):  
  Encoding:  1100 ooaa aabb bccc
  Encoding description:  op (o); register rA or reg pair r(aaaa/2)p (a); 
    reg pair rBp [not always used] (b); reg pair rCp (c); 
    high byte of 16-bit immediate value (i);
    low byte of 16-bit immediate value (j);
  Instructions
    Indexed Load/store instructions:
      1. ldrx (Load 8-bit value from memory at address [rBp + rCp] into rA)
      2. strx (Store rA to memory at address [rBp + rCp])
      3. ldpx (Load 16-bit value from memory at address [rBp + rCp] into
      rAp)
      4. stpx (Store rAp to memory at address [rBp + rCp])


Group 4 (Branching instructions):  
  Encoding:  1101 oooo iiii iiii
  Encoding description:  op (o); immediate value (i)
    Branching instructions (note that iiii iiii is a SIGNED 8-bit integer):
      1. bra (branch always)
      2. bnv (branch never, a form of NOP)
      3. bne (branch when Z == 0)
      4. beq (branch when Z == 1)
      5. bcc (branch when C == 0 [unsigned less than])
      6. bcs (branch when C == 1 [unsigned greater than or equal])
      7. bls (branch when ( ( C == 1 and Z == 0 ) or ( Z == 1 ) )
      [unsigned less than or equal])
      8. bhi (branch when C == 0 and Z == 1 [unsigned greater than])
      9. bvc (branch when V == 0)
      10. bvs (branch when V == 1)
      11. bpl (branch when N == 0)
      12. bmi (branch when N == 1)


Group 5 (Instructions encoded with four bytes instead of two so that there
can be 16-bit immediate values):  
  Encoding:  1110 00oo oaaa abbb   iiii iiii jjjj jjjj
  Encoding description:  op (o); 
    register rA, or reg pair r(aaaa/2)p [denoted rAp, so the least
    significant bit of aaaa is ignored] (a); 
    reg pair rBp [not always used] (b);  
    high byte of 16-bit immediate value (i);
    low byte of 16-bit immediate value (j);
  Instructions
    Extended copy instructions:
      1. cpypi (COPY Pair Immediate, which sets the a register pair rAp
      to a 16-bit value in one instruction, but in twice the number of
      cycles due to using more than two bytes [can be used a as a jump
      immediate by copying a 16-bit immediate value to the pc] [this
      instruction ONLY has an advantage over using two successive cpyi
      instructions when used to copy a 16-bit immediate value to the pc])
    Call instructions
      1. calli (CALL Immediate, which sets the link register to the
      return address, then sets the program counter to the destination
      address)
    Indexed Load/store instructions:
      1. ldrxi (Load 8-bit value from memory at address [rBp + 16-bit
      Immediate value] into rA)
      2. strxi (Store rA to memory at address [rBp + 16-bit Immediate
      value])
      3. ldpxi (Load 16-bit value from memory at address [rBp + 16-bit
      Immediate value] into rAp)
      rAp)
      4. stpxi (Store rAp to memory at address [rBp + 16-bit
      Immediate value])




