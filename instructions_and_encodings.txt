Note that register pairs are fixed to have their high byte stored in a
register rX and their low byte stored in another register r(X + 1) such
that X is an even number.  

Here are some example register pairs:  r0p (high byte r0, low byte r1), 
  r2p (high byte r2, low byte r3), r4p (high byte r4, low byte r5), etc.


Special register pairs:  
  1)  The program counter's two bytes are stored in the register pair
  r14p.  If there is ever an assembler for this CPU, "pc" (without
  quotes) will be an alias for "r14p" (without quotes).
  2)  The link register's two bytes are stored in the register pair r12p
  (enforced by the hardware, but only relevant to the call instruction).
  If there is ever an assembler for this CPU, "lr" (without quotes) will be
  an alias for "r12p" (without quotes).
  3)  As an ASSEMBLER CONVENTION, the stack pointer's two bytes are stored
  in the register pair r10p.  If there is ever an assembler for this
  CPU, "sp" (without quotes) will be an alias for "r10p" (without
  quotes).



Instruction encodings:

Type 1:  0ooo aaaa iiii iiii
  Encoding description:  op (o); 
  register rA, or reg pair r(aaaa/2)p [denoted rAp, so the least
  significant bit of aaaa is ignored] (a); 
  8-bit immediate value (i)
  Instructions:  
    Arithmetic instructions:
      1. addi
      2. adci
      
      3. subi (ASSEMBLER ALIAS for addi with the two's complement of the
      immediate value)
      
      4. sbci (ASSEMBLER ALIAS for adci with the one's complement of the
      immediate value)
      
      5. cmpi
    Copy instructions:
      6. cpyi (CoPY Immediate)


Type 2:  10oo oooo aaaa bbbb
  Encoding description:  op (o); 
  register rA, or reg pair r(aaaa/2)p [denoted rAp, so the least
  significant bit of aaaa is ignored] (a); 
  register rB, or reg pair r(bbbb/2)p [denoted rBp, so the least
  significant bit of bbbb is ignored] (b)
  Instructions:  
    Arithmetic instructions:
      1. add
      2. adc
      
      3. sub
      4. sbc
      
      5. cmp
      
    Bitwise instructions with two register operands:
      1. and
      2. orr
      3. xor
    
    Complement instructions with one register operand (rB ignored):
      1. inv (one's complement of rA)
      2. invp (one's complement of rAp)
      3. neg (two's complement of rA)
      4. negp (two's complement of rAp) 
    
    Bitshifting (and rotating) instructions that use the value of rB as the
    number of bits to shift by:
      1. lsl
      2. lsr
      3. asr
      4. rol
      5. ror
    
    Bit rotating instructions that use carry as bit 8 and that use the
    value of rB as the number of bits to rotate by:
      1. rolc
      2. rorc
    
    Bitshifting (and rotating) instructions that do a 16-bit shift or
    rotate on the reg pair rAp, using rB as the number of bits to shift by:
      1. lslp
      2. lsrp
      3. asrp
      4. rolp
      5. rorp
    
    Bit rotating instructions that use carry as bit 16 for a 16-bit rotate
    of the reg pair rAp, using rB as the number of bits to rotate by:
      1. rolcp
      2. rorcp
    
    Copy instructions:
      1. cpy (CoPY from one register to another register)
      2. cpyp (CoPY from reg Pair rAp to reg Pair rBp)
      
    Swap instructions:
      1. swp (SWap register Pair, also can be used as a combined "call",
      "jump", and "return" instruction by swapping some other register pair
      with the "pc" [r14] register pair)
    
    Call instruction (Description:  sets the link register to the return
    address, then sets the program counter to the address contained in
    the reg pair rAp):
      1. call (CALL subroutine at address in reg pair rAp)
    
    8-bit Load/store instructions:
      1. ldr (LoaD contents into Register rA from memory)
      2. str (STore Register rA contents to memory)


Type 3:  1100 aaaa bbbo ccco
  Encoding description:  op (o); register rA or reg pair r(aaaa/2)p (a); 
  reg pair rBp [not always used] (b); reg pair rCp (c); 
  high byte of 16-bit immediate value (i);
  low byte of 16-bit immediate value (j);
  Instructions
    Indexed Load/store instructions:
      1. ldrx (Load 8-bit value from memory at address [rBp + rCp] into rA)
      2. strx (Store rA to memory at address [rBp + rCp])


Type 4 (four bytes):  1101 aaaa bbbo oo00   iiii iiii jjjj jjjj
  Encoding description:  op (o); 
  register rA, or reg pair r(aaaa/2)p [denoted rAp, so the least
  significant bit of aaaa is ignored] (a); 
  reg pair rBp [not always used] (b);  
  high byte of 16-bit immediate value (i);
  low byte of 16-bit immediate value (j);
  Instructions
    Extended copy instructions:
      1. cpypi (COPY Pair Immediate, which sets the a register pair rAp
      to a 16-bit value in one instruction, but in twice the number of
      cycles due to using more than two bytes [can be used a as a jump
      immediate by copying a 16-bit immediate value to the pc] [this
      instruction ONLY has an advantage over using two successive cpyi
      instructions when used to copy a 16-bit immediate value to the pc])
    Call instructions
      1. calli (CALL Immediate, which sets the link register to the
      return address, then sets the program counter to the destination
      address)
    Indexed Load/store instructions:
      1. ldrxi (Load 8-bit value from memory at address [rBp + 16-bit
      Immediate value] into rA)
      2. strxi (Store rA to memory at address [rBp + 16-bit Immediate
      value])


Type 5:  1110 oooo iiii iiii
  Encoding description:  op (o); immediate value (i)
    Branching instructions (note that iiii iiii is a SIGNED 8-bit integer):
      1. bra (branch always)
      2. bnv (branch never, a form of NOP)
      3. bne (branch when Z == 0)
      4. beq (branch when Z == 1)
      5. bcc (branch when C == 0 [unsigned less than])
      6. bcs (branch when C == 1 [unsigned greater than or equal])
      7. bls (branch when C == 0 and Z == 1 [unsigned less than or equal])
      8. bhi (branch when C == 1 and Z == 0 [unsigned greater than])

//Type 1:  0ooo aaaa iiii iiii
//  Encoding description:  op (o); rA (a); immediate value (i)
//  Instructions:  
//    Arithmetic instructions:
//      addi, adci, 
//      
//      subi (ASSEMBLER ALIAS for addi with the two's complement of the
//      immediate value), 
//      
//      sbci (ASSEMBLER ALIAS for adci with the one's complement of the
//      immediate value), 
//      
//      cmpi
//    Copy instructions:
//      cpyi (CoPY Immediate)
//
//
//Type 2:  10oo oooo aaaa bbbb
//  Encoding description:  op (o); rA (a); rB (b)
//  Instructions:  
//    Arithmetic instructions:
//      add, adc, 
//      
//      sub, sbc, 
//      
//      cmp
//    Bitwise instructions with two register operands:
//      and, orr, xor,
//    Bitshifting (and rotating) instructions that use the value of rB as the
//    number of bits to shift by:
//      lsl, lsr, asr, rol, ror
//    Bit rotating instructions that use carry as an extra bit
//    (either bit 8 or bit 0) and that use the value of rB as the number of
//    bits to rotate by:
//      rolc, rorc
//    Copy instructions:
//      cpy (CoPY from one register to another register)
//
//
//Type 4:  1110 oooo iiii iiii
//  Encoding description:  op (o); immediate value (i)
//    Branching instructions (note that iiii iiii is a SIGNED 8-bit integer):
//      bra (branch always), bnv (branch never, a form of NOP)
//      bne (branch when Z == 0), beq (branch when Z == 1), 
//      bcc (branch when C == 0 [unsigned less than]), 
//      bcs (branch when C == 1 [unsigned greater than or equal]),
//      bls (branch when C == 0 and Z == 1 [unsigned less than or equal]),
//      bhi (branch when C == 1 and Z == 0 [unsigned greater than]),
//
//
//Type 5:  1111 oooo aaaa bbbo
//  Encoding description:  op (o); rA or reg pair r(aaaa/2)p (a); 
//  reg pair rBp (b);
//  Instructions:  
//    Load/store instructions:
//      ldr (LoaD contents into Register rA from memory), 
//      str (STore Register rA contents to memory),
//    Swap instructions:
//      swp (SWap register Pair, also can be used as a combined "call",
//      "jump", and "return" instruction by swapping some other register pair
//      with the "pc" [r14] register pair)
//    Copy instructions:
//      cpyp (CoPY from reg Pair rAp to reg Pair rBp)
//    Call instruction (Description:  sets the link register to the return
//    address, then sets the program counter to the address contained in
//    the reg pair rAp):
//      call (CALL subroutine at address in reg pair rAp)





//Type 4:  1110 oooo iiii iiii
//  Encoding description:  op (o); immediate value (i)
//    Branching instructions (note that iiii iiii is a SIGNED 8-bit integer):
//      bra (branch always), bnv (branch never, a form of NOP)
//      bne (branch when Z == 0), beq (branch when Z == 1), 
//      bcc (branch when C == 0 [unsigned less than]), 
//      bcs (branch when C == 1 [unsigned greater than or equal]),
//      bls (branch when C == 0 and Z == 1 [unsigned less than or equal]),
//      bhi (branch when C == 1 and Z == 0 [unsigned greater than]),
//
//
//Type 5:  1111 oooo aaaa bbb0
//  Encoding description:  op (o); rA (a); reg pair rBp (b);
//  Instructions:  
//    Load/store instructions:
//      ldr (LoaD contents into Register rA from memory), 
//      str (STore Register rA contents to memory),
//
//
//Type 6:  1111 oooo aaa0 bbb1
//  Encoding description:  op (o); reg pair rAp (a); reg pair rBp (b);
//  Instructions:  
//    Swap instructions:
//      swp (SWap register Pair, also can be used as a combined "call",
//      "jump", and "return" instruction by swapping some other register pair
//      with the "pc" [r14] register pair)
//    Copy instructions:
//      cpyp (CoPY from reg Pair rAp to reg Pair rBp)
//    Call instruction (Description:  sets the link register to the return
//    address, then sets the program counter to the address contained in
//    the reg pair rAp):
//      call (CALL subroutine at address in reg pair rAp)
