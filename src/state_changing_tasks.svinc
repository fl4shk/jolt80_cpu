// This file is part of Small Practice CPU.
// 
// Copyright 2016 by Andrew Clark (FL4SHK).
// 
// Small Practice CPU is free software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License, or (at
// your option) any later version.
// 
// Small Practice CPU is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public License along
// with Small Practice CPU.  If not, see <http://www.gnu.org/licenses/>.


`ifndef state_changing_tasks_svinc
`define state_changing_tasks_svinc

`define get_temp_pc { temp_regs[0], temp_regs[1] }

// This task exists to help reduce bugs fro
task set_pc_and_dio_addr;
	input [`cpu_addr_msb_pos:0] val;
	
	`get_cpu_rp_pc <= val;
	data_inout_addr <= val;
endtask


//task advance_pc_etc_after_reg_instr;
task advance_pc_etc_after_instr;
	//set_pc_and_dio_addr(`get_pc_after_reg_instr);
	set_pc_and_dio_addr(`get_temp_pc);
endtask



task disable_dio_we;
	data_inout_we <= 1'b0;
endtask

task enable_dio_we;
	data_inout_we <= 1'b1;
endtask

// Prepare to, on the next cycle, load an 8-bit value
task prep_load_8_no_addr;
	data_acc_sz <= pkg_cpu::cpu_data_acc_sz_8;
	disable_dio_we();
endtask
task prep_load_8_with_addr;
	input [`cpu_addr_msb_pos:0] read_addr;
	
	data_inout_addr <= read_addr;
	prep_load_8_no_addr();
endtask

// Prepare to, on the next cycle, write an 8-bit value
task prep_store_8;
	input [`cpu_data_inout_8_msb_pos:0] write_data;
	input [`cpu_addr_msb_pos:0] write_addr;
	
	data_inout_addr <= write_addr;
	//data_inout <= write_data;
	temp_data_out <= write_data;
	data_acc_sz <= pkg_cpu::cpu_data_acc_sz_8;
	enable_dio_we();
endtask

// Prepare to, on the next cycle, load a 16-bit value
task prep_load_16_no_addr;
	data_acc_sz <= pkg_cpu::cpu_data_acc_sz_16;
	disable_dio_we();
endtask
task prep_load_16_with_addr;
	input [`cpu_addr_msb_pos:0] read_addr;
	
	data_inout_addr <= read_addr;
	prep_load_16_no_addr();
endtask




// Advance the PC after a non-branch, non-call instruction
task prep_load_instr_hi_after_reg;
	curr_state <= pkg_cpu::cpu_st_load_instr_hi;
	//advance_pc_etc_after_reg_instr();
	advance_pc_etc_after_instr();
	prep_load_16_no_addr();
endtask

task prep_load_instr_hi_after_bc;
	$display("prep_load_instr_hi_after_bc");
	curr_state <= pkg_cpu::cpu_st_load_instr_hi;
	prep_load_16_no_addr();
endtask

task prep_load_instr_hi_generic;
	//if (!final_instr_is_32_bit)
	//begin
	//	$display("16-bit instruction");
	//	//prep_load_instr_hi_reg_after_16();
	//end
	//else // if (final_instr_is_32_bit)
	//begin
	//	$display("32-bit instruction");
	//	//prep_load_instr_hi_reg_after_32();
	//end
	
	if (!instr_is_branch_or_call)
	begin
		$display("!instr_is_branch_or_call");
		prep_load_instr_hi_after_reg();
	end
	
	else // if (instr_is_branch_or_call)
	begin
		$display("instr_is_branch_or_call");
		prep_load_instr_hi_after_bc();
	end
endtask

task prep_load_instr_lo_reg;
	curr_state <= pkg_cpu::cpu_st_load_instr_lo;
	//advance_dio_addr_for_instr_lo();
	//advance_pc_etc_after_reg_instr();
	advance_pc_etc_after_instr();
	prep_load_16_no_addr();
endtask



task prep_update_pc_etc_after_ipc;
	curr_state <= pkg_cpu::cpu_st_update_pc_after_non_bc_ipc;
endtask



`endif		// state_changing_tasks_svinc
