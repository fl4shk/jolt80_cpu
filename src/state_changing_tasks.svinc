// This file is part of Small Practice CPU.
// 
// Copyright 2016 by Andrew Clark (FL4SHK).
// 
// Small Practice CPU is free software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License, or (at
// your option) any later version.
// 
// Small Practice CPU is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public License along
// with Small Practice CPU.  If not, see <http://www.gnu.org/licenses/>.


`ifndef state_changing_tasks_svinc
`define state_changing_tasks_svinc

//`define get_temp_pc { temp_pc[0], temp_pc[1] }
`define get_pc_adjuster_outputs { pc_adjuster_out_hi, pc_adjuster_out_lo }

// This task exists to help reduce bugs fro
task set_pc_and_dio_addr;
	input [`cpu_addr_msb_pos:0] val;
	
	`get_cpu_rp_pc <= val;
	data_inout_addr <= val;
endtask


////task advance_pc_etc_after_reg_instr;
////task advance_pc_etc_after_instr;
//task advance_pc_etc_after_load_instr_part;
//	//set_pc_and_dio_addr(`get_pc_after_reg_instr);
//	//$display("advance_pc_etc_after_load_instr_part:  %h %h", 
//	//	`get_cpu_rp_pc, `get_temp_pc );
//	//set_pc_and_dio_addr(`get_temp_pc);
//endtask



task disable_dio_we;
	data_inout_we <= 1'b0;
endtask

task enable_dio_we;
	data_inout_we <= 1'b1;
endtask

// Prepare to, on the next cycle, load an 8-bit value
task prep_load_8_no_addr;
	data_acc_sz <= pkg_cpu::cpu_data_acc_sz_8;
	disable_dio_we();
endtask
task prep_load_8_with_addr;
	input [`cpu_addr_msb_pos:0] read_addr;
	
	data_inout_addr <= read_addr;
	prep_load_8_no_addr();
endtask

// Prepare to, on the next cycle, write an 8-bit value
task prep_store_8;
	input [`cpu_data_inout_8_msb_pos:0] write_data;
	input [`cpu_addr_msb_pos:0] write_addr;
	
	data_inout_addr <= write_addr;
	//data_inout <= write_data;
	temp_data_out <= write_data;
	data_acc_sz <= pkg_cpu::cpu_data_acc_sz_8;
	enable_dio_we();
endtask

// Prepare to, on the next cycle, load a 16-bit value
task prep_load_16_no_addr;
	data_acc_sz <= pkg_cpu::cpu_data_acc_sz_16;
	disable_dio_we();
endtask
task prep_load_16_with_addr;
	input [`cpu_addr_msb_pos:0] read_addr;
	
	data_inout_addr <= read_addr;
	prep_load_16_no_addr();
endtask




// Advance the PC after a non-branch, non-call instruction
task prep_load_instr_hi_after_reg;
	curr_state <= pkg_cpu::cpu_st_load_instr_hi;
	//advance_pc_etc_after_load_instr_part();
	
	//advance_pc_etc_after_reg
	prep_load_16_no_addr();
endtask

task prep_load_instr_hi_after_bc;
	$display("prep_load_instr_hi_after_bc");
	curr_state <= pkg_cpu::cpu_st_load_instr_hi;
	prep_load_16_no_addr();
endtask

task prep_update_pc_etc_after_non_bc_ipc;
	curr_state <= pkg_cpu::cpu_st_update_pc_after_non_bc_ipc;
	
endtask

//task update_temp_pc_during_start_exec_instr;
//	
//	if (non_bc_instr_possibly_changes_pc)
//	begin
//	end
//	
//endtask

task prep_load_instr_hi_generic;
	
	if (!instr_is_branch_or_call)
	begin
		$display("!instr_is_branch_or_call");
		if (!non_bc_instr_possibly_changes_pc)
		begin
			$display("!non_bc_instr_possibly_changes_pc");
			prep_load_instr_hi_after_reg();
		end
		
		else // if (non_bc_instr_possibly_changes_pc)
		begin
			$display("non_bc_instr_possibly_changes_pc");
			prep_update_pc_etc_after_non_bc_ipc();
		end
	end
	
	else // if (instr_is_branch_or_call)
	begin
		$display("instr_is_branch_or_call");
		prep_load_instr_hi_after_bc();
	end
	
endtask

task prep_load_instr_lo_reg;
	curr_state <= pkg_cpu::cpu_st_load_instr_lo;
	//advance_dio_addr_for_instr_lo();
	//advance_pc_etc_after_reg_instr();
	//$display( "prep_load_instr_lo_reg:  %h %h", `get_cpu_rp_pc,
	//	`get_temp_pc );
	//advance_pc_etc_after_load_instr_part();
	//prep_pc_adjuster_during_load_instr_lo();
	prep_load_16_no_addr();
	//prep_pc_adjuster_before_load_instr_lo();
endtask






//task comb_logic_prep_pc_adjuster_inputs_generic;
//	input [`cpu_imm_value_8_msb_pos:0] specific_num_bytes;
//	
//	//{ pc_adjuster_a_in_hi, pc_adjuster_a_in_lo, pc_adjuster_b_in_hi,
//	//	pc_adjuster_b_in_lo } 
//	//	<= { `get_cpu_rp_pc, 8'h0, specific_num_bytes };
//	{ pc_adjuster_a_in_hi, pc_adjuster_a_in_lo, pc_adjuster_b_in_hi,
//		pc_adjuster_b_in_lo } 
//		= { `get_cpu_rp_pc, 8'h0, specific_num_bytes };
//endtask
//
//task comb_logic_prep_pc_adjuster_during_load_instr_hi;
//	//$display("comb_logic_prep_pc_adjuster_during_load_instr_hi");
//	comb_logic_prep_pc_adjuster_inputs_generic(`instr_16_num_bytes);
//endtask
//task comb_logic_prep_pc_adjuster_during_load_instr_lo;
//	//$display("comb_logic_prep_pc_adjuster_during_load_instr_lo");
//	comb_logic_prep_pc_adjuster_inputs_generic(`instr_32_num_bytes);
//endtask
//
//task comb_logic_prep_pc_adjuster_after_non_bc_ipc;
//	comb_logic_prep_pc_adjuster_during_load_instr_hi();
//endtask

task comb_logic_prep_pc_adjuster_for_branch;
	input [`instr_g4_imm_value_msb_pos:0] branch_offset;
	
	{ pc_adjuster_a_in_hi, pc_adjuster_a_in_lo, pc_adjuster_b_in_hi,
		pc_adjuster_b_in_lo }
		= { `get_cpu_rp_pc, 8'h0, branch_offset };
	
endtask

task seq_logic_grab_pc_adjuster_outputs;
	//$display("seq_logic_grab_pc_adjuster_outputs");
	set_pc_and_dio_addr(`get_pc_adjuster_outputs);
endtask

task comb_logic_prep_pc_inc_generic;
	input [`cpu_imm_value_16_msb_pos:0] specific_num_bytes;
	
	{ the_pc_inc_pc_in, the_pc_inc_offset_in } 
		= { `get_cpu_rp_pc, specific_num_bytes };
endtask

task comb_logic_prep_pc_inc_during_load_instr_hi;
	comb_logic_prep_pc_inc_generic(`instr_16_num_bytes);
endtask
task comb_logic_prep_pc_inc_during_load_instr_lo;
	comb_logic_prep_pc_inc_generic(`instr_32_num_bytes);
endtask

task comb_logic_prep_pc_inc_after_non_bc_ipc;
	comb_logic_prep_pc_inc_during_load_instr_hi();
endtask

task seq_logic_grab_pc_inc_outputs;
	set_pc_and_dio_addr(the_pc_inc_pc_out);
endtask


`endif		// state_changing_tasks_svinc
